<!-- build time:Sat Nov 16 2019 08:11:22 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.2.2"><script></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/bug-report-32x32.png?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/bug-report-16x16.png?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="一只不掉毛的程序猿" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="反射java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制。"><meta property="og:type" content="article"><meta property="og:title" content="java基础（二）"><meta property="og:url" content="http://blog.xiongchang.vip/java基础（二）.html"><meta property="og:site_name" content="一只不掉毛的程序猿"><meta property="og:description" content="反射java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制。"><meta property="og:image" content="http://imgs.xiongchang.vip/img_14.png"><meta property="og:image" content="http://imgs.xiongchang.vip/img_13.jpg"><meta property="og:image" content="http://imgs.xiongchang.vip/img_12.jpg"><meta property="og:updated_time" content="2019-11-15T06:31:49.626Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java基础（二）"><meta name="twitter:description" content="反射java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制。"><meta name="twitter:image" content="http://imgs.xiongchang.vip/img_14.png"><link rel="canonical" href="http://blog.xiongchang.vip/java基础（二）"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>java基础（二） | 一只不掉毛的程序猿</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">一只不掉毛的程序猿</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.xiongchang.vip/java基础（二）.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Mr.xiong"><meta itemprop="description" content="日行一善"><meta itemprop="image" content="http://imgs.xiongchang.vip/head.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一只不掉毛的程序猿"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java基础（二）</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-11-03 19:57:04" itemprop="dateCreated datePublished" datetime="2019-11-03T19:57:04+08:00">2019-11-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-11-15 14:31:49" itemprop="dateModified" datetime="2019-11-15T14:31:49+08:00">2019-11-15</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/java基础（二）.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/java基础（二）.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>8.3k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>8 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><ul><li><p>java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法，对于任意一个对象，都能够调用它的任意一个方法；这种<strong>动态获取</strong>信息以及<strong>动态调用</strong>对象的方法的功能称为java语言的反射机制。<a id="more"></a></p></li><li><p>简单的说：反射机制是程序在<strong>运行时</strong>能够获取自身的信息。在java中，只要给定类的名字，那么就可以通过反射机制来获得类的所有信息。包括其访问的修饰符、父类、实现的接口、属性和方法的所有信息，并可在运行时创建对象、修改属性（包括私有的）、调用方法（包括私有的）。</p></li><li><p>静态编译：在编译时确定类型，绑定对象，即通过。</p><p><code>Student stu = new Student(&quot;zhangsan&quot;,30);</code></p></li><li><p>动态编译：运行时确定类型，绑定对象。</p><p>动态编译最大限度发挥了java的灵活性，体现了动态的应用，用以降低类之间的耦合性。<code>Class.forName(&quot;com.mysql.jdbc.Driver.class&quot;).newinstance();</code></p></li><li><p>反射机制优缺点：</p><p>优点：可实现动态创建对象和编译，体现出很大的灵活性</p><p>缺点：使用反射基本上是一种解释操作，这类操作总是慢于直接执行的相同操作。</p></li><li><p>提供的主要功能：</p><ol><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造任意一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法</li></ol></li><li><p>Class对象的获取：</p><ul><li><code>object.getClass()</code></li><li><code>class.getSuperclass()</code></li><li><code>.class语法</code> 直接获取</li><li><code>Class.forName(类名)</code> 用的较多</li><li><code>Primitive.TYPE</code> 基本数据类型的包装类获取Class的方式</li></ul></li><li><p><code>java.lang.reflect</code>库：</p><ul><li>Class类与java.lang.reflect类库一起对反射的概念进行支持。</li></ul></li><li><p>java.lang包下：</p><ul><li>Class<t>:表示一个正在运行的java应用程序中的类和接口，是Reflection的起源。</t></li><li>java.lang.reflect包下：</li><li>Field类：代表类的成员变量（成员变量也称为类的属性）；<ul><li>Method类：代表类的方法；</li><li>Constructor类：代表类的构造方法；</li><li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。</li></ul></li></ul></li><li><p>通过反射实例化对象：</p><ul><li>有些没办法new时，只能用反射动态生成</li><li>实例化无参构造函数的对象，两种方式：<ul><li><code>Class.newInstance();</code></li><li><code>Class.getConstructor(new Class[]{}).newInstance(new Object[]{})</code></li></ul></li></ul></li><li><p>实例化带参构造函数的对象</p></li><li><p><code>clazz.getConstructor(Class&lt;?&gt;...parameterTypes).newInstance(Object...initargs)</code></p></li><li><p>通过反射获取并调用方法：</p><ul><li><p>获得当前类以及超类的public Method</p><p><code>Method[] arrMethods=classType.getMethods();</code></p></li><li><p>获得当前类申明的所有Method</p><p><code>Method[] arrMethods=classType.getDeclaredMethods();</code></p></li><li><p>获得当前类以及超类指定的public Method</p><p><code>Method method=classType.getMethod(String name,Class&lt;?&gt;...parameterType);</code></p></li><li><p>获得当前类申明的指定的Method</p><p><code>Method method=classType.getDeclaredMethod(String name,Class&lt;?&gt;...parameterTypes);</code></p></li><li><p>通过反射动态运行指定Method</p><p><code>Object obj=method.invoke(Object obj,Object args)</code></p></li></ul></li><li><p>通过反射获取并调用属性：</p><ul><li><p>获得当前类以及超类public Field</p><p><code>Filed[] arrFields=classType.getFields();</code></p></li><li><p>获得当前类申明的所有Filed</p><p><code>Filed[] arrFields=classType.getDeclaredFields();</code></p></li><li><p>获得当前类以及超类指定的public Filed</p><p><code>Field field=classType.getField(String name);</code></p></li><li><p>获得当前类申明的指定的Field</p><p><code>Field field=classType.getDeclaredField(String name);</code></p></li><li><p>通过反射动摇设定Field的值</p><p><code>field.set(Object obj,Object value);</code></p></li><li><p>通过反射动态湖区Field的值</p><p><code>Object obj =field.get(Object obj);</code></p></li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>程序：安装在磁盘上的一段指令集合，<strong>静态概念</strong></p></li><li><p>进程：运行中的程序，<strong>动态概念</strong>。每个进程有独立的资源空间。（<strong>分配者</strong>）</p></li><li><p>线程：又称为轻量级进程，线程是进程中的一个<strong>实体</strong>（<strong>工作者</strong>）</p></li><li><p>多线程：在单个程序中可以同时运行多个不同的线程执行不同的任务。</p></li></ul><h3 id="多线程特点"><a href="#多线程特点" class="headerlink" title="多线程特点"></a>多线程特点</h3><ul><li><p>一个进程可以包含一个或多个线程</p></li><li><p>一个程序实现多个代码同时交替运行就需要产生多个线程</p></li><li><p>程序本身不拥有系统资源，与同属一个进程的其他线程共享所在进程所拥有的资源</p></li><li><p>同一进程中的多个线程之间可以并发执行。（由cpu抽时间完成）</p></li></ul><h3 id="多线程目的"><a href="#多线程目的" class="headerlink" title="多线程目的"></a>多线程目的</h3><ul><li>大限度利用cpu，对于多核（单核不会并发执行），利用cpu与和I/O等资源打交道的空隙时间。</li></ul><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><ul><li><p>通过<strong>继承Thread类</strong>创建线程（类）</p><ul><li>普通java类如继承自Thread类，就成为一个线程类，并可以通过该类的start方法类启动线程，执行线程代码</li><li>Thread类的子类可直接实例化，但在子类中必须覆盖<strong>run方法</strong>才能真正运行线程的代码。</li></ul></li><li><p>通过<strong>实现Runnable接口</strong>创建线程（接口）</p><ul><li><p>实现Runnable接口的类必须借助Thread类才能创建线程。</p></li><li><p>通过Runnable接口创建线程分为两步：</p><ul><li><p>创建实现Runnable接口的类的实例；</p></li><li><p>创建一个Thread类对象，将第一步实例化得到的Runnable对象作为参数传入Thread；类的构造方法。</p></li></ul></li><li><p>通过Thread类的<strong>start方法</strong>启动线程。</p></li></ul></li></ul><h3 id="创建并运行线程"><a href="#创建并运行线程" class="headerlink" title="创建并运行线程"></a>创建并运行线程</h3><ul><li><p>新建状态（New Thread）：</p><ul><li><p>在Java中，使用new创建一个线程后，该线程是一个空对象，它具备线程的一些特征，但此时系统没有为其分配空间，此时处于创建状态。</p></li><li><p>线程处于创建状态时，可通过Thread类的方法来设置线程各个属性。</p><p>如：线程的优先级（setPriority）、线程名（setName）和线程的类型（setDaemon）等</p></li></ul></li><li><p>就绪状态（Runnable）：</p></li><li><p>使用<strong>start（）方法</strong>启动一个线程后，系统为该线程分配了除cpu外的所需资源，使该线程处于就绪状态。此外，若某个线程执行了<strong>yield（）</strong>方法，那么该线程会被暂时剥夺cpu资源，重新就绪。（跳出排队，重新开始排队）</p></li><li><p>运行状态（Running）：</p><ul><li>Java运行系统通过调度选中一个处于就绪状态的线程，使其占有cpu并转为运行状态。此时，系统真正执行线程的<strong>run（）</strong>方法。</li><li>可通过Thread类的<strong>isAlive方法</strong>判断是否处于就绪/运行状态：<ul><li>true（就绪/运行） false（阻塞/停止）</li></ul></li></ul></li></ul><h3 id="阻塞和唤醒线程"><a href="#阻塞和唤醒线程" class="headerlink" title="阻塞和唤醒线程"></a>阻塞和唤醒线程</h3><ul><li><p>阻塞状态（Blocked）</p><ul><li>一个正在运行的线程因某些原因不能继续运行时，就进入阻塞状态。</li></ul></li><li><p>阻塞原因：</p><ul><li>当执行了某个线程对象的sleep（）等阻塞类型的方法时，该线程对象会被置入一个阻塞集（Blocked Pool）内，等待超时而自动苏醒。</li><li>当多个线程试图进入某个同步区域（synchronized）时，没能进入该同步区域的线程会被置入锁定集（Lock Pool），直到获得该同步区域的锁，进入就绪状态</li><li>当线程执行了某个对象的<strong>wait（）</strong>方法时，线程会被置入该对象的等待集（Wait Pool）中，直到执行了该对象的<strong>notify（）</strong>方法，<strong>wait（）</strong>/<strong>notify（）</strong>方法的执行要求线程首先获取到该对象的锁。</li></ul></li></ul><h3 id="死亡状态（Dead）"><a href="#死亡状态（Dead）" class="headerlink" title="死亡状态（Dead）"></a>死亡状态（Dead）</h3><ul><li>线程在run（）方法执行结束后进入死亡状态，此外，如果线程执行了<strong>interrupt（）</strong>或<strong>stop（）</strong>方法，那么它也会以异常退出的方式进入死亡状态。</li></ul><h3 id="终止线程的三种方法"><a href="#终止线程的三种方法" class="headerlink" title="终止线程的三种方法"></a>终止线程的三种方法</h3><ul><li><p>使用退出标志，使线程正常退出，也就是当run方法完成后线程终止，推荐使用。</p></li><li><p>使用<strong>stop方法</strong>强行终止线程（<strong>不推荐</strong>使用，因为stop和suspend、resume一样，可能发生不可预料的结果）</p></li><li><p>使用<strong>interrupt方法</strong>中断线程。</p></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li><p>目的：</p><ol><li>防止多个线程处理一个数据对象时，对数据造成破坏</li><li>保证多线程安全访问竞争资源的一种手段</li></ol></li><li><p>同步和锁：</p><ul><li>Java中每个对象都有一个内置锁；</li><li>当运行到非静态的<strong>synchroniezd</strong>同步方法上时，自动获得正在执行代码了的当前实例（this实例）有关的锁；</li><li>获得一个对象的锁也称为获取锁、锁定对象、在对象上同步。当程序运行到synchroniezd同步方法或代码块时该对象锁才起作用；</li><li>一个对象一个锁，一个线程获得该锁，其他线程无法获得，直到释放锁，才可以获得。</li></ul></li><li><p>对于同步，一般而言在Java代码中需要完成两个操作：</p><ol><li>把竞争访问的资源表示为<strong>private</strong>；</li><li>同步那些访问资源的代码，使用synchronized关键字来修饰方法或代码块。当synchronized方法执行完或发生异常时，会自动释放锁。</li></ol></li><li><p>线程通信：（生产者-消费者问题）</p><ul><li>Java提供了3个重要方法巧妙解决线程间的通信问题：<ul><li><strong>Wait</strong>()：使调用该方法的线程释放共享资源的锁，然后从运行态退出，进入等待队列，直到被再次唤醒；</li><li><strong>Notify</strong>()：唤醒队列中第一个等待统一共享资源的进程，并使该进程退出等待队列，进入可运行态；</li><li><strong>notifyAll</strong>()：唤醒队列中所有等待统一共享资源的进程，并使该进程退出等待队列，进入可运行态，此时优先级最高的最先执行；</li></ul></li></ul></li></ul><h2 id="I-O框架"><a href="#I-O框架" class="headerlink" title="I/O框架"></a>I/O框架</h2><ul><li><strong>File</strong>类：具体方法参照API文档</li></ul><h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><ul><li><p>程序调用自身的编程技巧称为递归（recursion）</p></li><li><p>在方法里，自身调用自身</p></li><li><p>在使用递归策略时，必须有一个明确的递归约束条件，称为递归出口（否则会死循环）</p></li></ul><h3 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h3><ul><li><p>流按其流向分为“输入流”和“输出流”（以内存为参照物）</p></li><li><p>流按数据传输单位分为“字节流”和“字符流”</p><ul><li>“字节流”用来读写8位二进制的字节（MP3，MP4，多媒体文件，图片，视频等）</li></ul><ul><li>“字符流”用来读写16位二进制的字符</li></ul></li><li><p>流按功能分为“节点流”和“过滤流”</p><ul><li>“节点流”用于直接操作目标设备的流。（直接跟数据源打交道）例如：磁盘或一块区域。</li><li>“过滤流”对节点流进行封装和链接，不直接跟数据源打交道。</li></ul></li></ul><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><ul><li><p><code>inputStream</code> 抽象类：</p><ul><li>字节流类用于向字节流读写8位二进制字节。以inputStream和outputStream为顶层类，它们都是抽象类</li><li>inputStream是定义了字节输入流的抽象类</li></ul></li><li><p><code>outputStream</code>抽象类：</p><ul><li>outputStream是定义了字节输出流的抽象类</li><li>该类所有方法返回void值，在出错情况下抛IOException异常</li></ul></li><li><p><code>FileinputStream</code>类：</p><ul><li>表示能从文件读取字节的inputStream类</li></ul></li><li><p><code>FileoutputStream</code>类：</p><ul><li>表示能从文件写入字节的outputStream类</li></ul></li><li><p><code>ByteArrayInput/OutputStream</code>类：</p><ul><li>ByteArrayInputStream是把字节数组当成源的输入流。</li><li>ByteArrayOutputStream是把字节数组当作目标的输出流。</li></ul></li><li><p>过滤流：</p><ul><li>过滤流仅仅是为底层透明地提供扩展功能的输入/输出流的包装，这些流一般由普通类的方法访问。</li><li>过滤字节流：<code>filterInput/OutputStream</code></li><li>这些类提供的方法和InputStream和OutputStream类的方法相同</li><li>常用的过滤流BufferedInput/OutputStream和DataInput/OutputStream<ul><li><code>BufferedInput/OutputStream</code>：需要使用已经存在的节点流来构造，提供带缓冲区的读写，提高了读写的效率。</li><li><code>DataInput/OutputStream</code>：数据输入输出流允许应用程序读写基本Java数据类型。应用程序可以使用数据输出流写入稍后由数据输入流读取。读写顺序要保持一致。</li></ul></li></ul><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3></li><li><p>字节流提供处理任何类型输入/输出操作的足够功能，但不能直接操作Unicode字符，因而需要字符流。</p></li><li><p>字符流层次结构的顶层是Reader和Writer抽象类。</p></li><li><code>Reader/Writer</code> 抽象类<ul><li>Reader是定义Java的流式字符输出模式的抽象类；</li><li>Writer是定义流式字符输出的抽象类；</li></ul></li><li><code>FileReader/FileWriter</code> 类<ul><li>FileReader 表示可以读取文件内容的Reader类；</li><li>FileWriter 表示可以写文件Writer类；</li></ul></li><li><code>BufferedReader/BufferedWriter</code> 类<ul><li>BufferedReader 通过缓冲输入提高性能；</li><li>BufferedWriter 通过缓冲输出提高性能；</li></ul></li></ul><h3 id="其他流"><a href="#其他流" class="headerlink" title="其他流"></a>其他流</h3><ul><li><code>ObjectInputStream/ObjectOutputStream</code> 类<ul><li>ObjectInputStream/ObjectOutputStream分别和FileInputStream/FileOutputStream一起使用时，可以为应用程序提供对对象的持久存储。</li><li>把对象以某种特定的编码格式输出称为<kbd>序列化</kbd>；把写入的编码格式内容还原成对象称为<kbd>反序列化</kbd>。</li><li>被序列化的对象必须实现<kbd>Serializable</kbd>接口。</li></ul></li><li><code>InputStreamReader/OutputStreamWriter</code> 类<ul><li>InputStreamReader/OutputStreamWriter 是转换流，是指将字节流与字符流之间的转换。</li><li>字符流底层还是字节流。</li><li>字节流中的数据都是字符时，转成字符流操作更加有效。</li><li>如果使用非默认编码保存文件或者读取文件时，需要用到转换流，因为字节流的重载构造方法中有指定编码格式参数，而FileReader和FileWriter是默认编码的文本文件。</li></ul></li><li><code>RandomAccessFile</code> 类<ul><li>支持对随机访问文件的读取和写入。</li><li>随机访问文件的行为类似存储在文件系统中的一个大型的byte数组，存在指向该隐含数组的光标或索引，称为文件指针。</li><li>输入操作从文件指针开始读取字节，随着对字节的读取而前移此文件的指针。</li><li>该文件指针可以通过<code>getFilePointer</code> 方法读取，通过<code>seek</code> 方法设置。</li></ul></li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="OSI-七层参考模型"><a href="#OSI-七层参考模型" class="headerlink" title="OSI 七层参考模型"></a>OSI 七层参考模型</h3><p><img src="http://imgs.xiongchang.vip/img_14.png"></p><ul><li><p>数据封装过程：</p><p><img src="http://imgs.xiongchang.vip/img_13.jpg"></p></li></ul><h3 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h3><p><img src="http://imgs.xiongchang.vip/img_12.jpg"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><ul><li>网络中每台主机都必须有一个唯一的IP地址；</li><li>因特网上的IP地址具有全球唯一性；</li><li>对应的类是：InetAddress类</li></ul><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><ul><li>端口号用来标识该计算机上的应用程序，代表此应用程序逻辑地址；</li><li>端口号使用一个16位的数字来表示，范围是在0 ~ 65535，推荐1024以下的端口号保留给预定义的服务。</li></ul><h3 id="常见传输协议"><a href="#常见传输协议" class="headerlink" title="常见传输协议"></a>常见传输协议</h3><ul><li>TCP是一种面向连接的保证可靠传输的协议，通过TCP协议传输，得到的是一个顺序的无差错的数据。</li><li>UDP是一种无连接的协议，灭个数据报都是一个独立的信息，包括完整的源地址或目的地址，它在网络上以任何可能的路径传往目的地，因此能否到达目的地，到达目的地的时间以及内容的正确性都是不能保证的。</li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><ul><li>常用的网络编程模型是<kbd>C/S</kbd>通信模式；</li><li>使用Socket进行网络通信的过程：<ul><li>服务器程序将一个套接字绑定到一个特定的端口，并通过此套接字等待和监听客户的连接请求；</li><li>客户程序通过服务器程序所在的主机名和端口号发出连接请求；</li><li>如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字；</li><li>客户、服务器通过读、写套接字进行通讯。</li></ul></li></ul><h3 id="基于TCP协议的Socket编程"><a href="#基于TCP协议的Socket编程" class="headerlink" title="基于TCP协议的Socket编程"></a>基于TCP协议的Socket编程</h3><ul><li>创建TCP<strong>服务端</strong>步骤：<ol><li>创建一个<code>ServerSocket</code>对象；</li><li>调用<code>accept()</code>方法接受客户请求；</li><li>从<code>Socket</code>中获取 <code>I/O 流</code>；</li><li>对 <code>I/O 流</code>进行读写操作，完成与<em>客户端</em>的交互；</li><li>关闭 I/O 流和Socket。</li></ol></li><li>创建TCP<strong>客户端</strong>步骤：<ol><li>创建一个<code>Socket</code>对象；</li><li>从<code>Socket</code>中获取<code>I/O 流</code>；</li><li>对 <code>I/O 流</code>进行读写操作，完成与<em>服务端</em>的交互；</li><li>关闭 I/O 流和Socket。</li></ol></li><li>强调：客户端和服务端进行数据传输时，<u>客户端的输入流</u>对应<u>服务端的输出流</u>，<u>客户端的输出流</u>对应<u>服务端的输入流</u>。</li></ul><h3 id="基于UDP协议的Socket编程"><a href="#基于UDP协议的Socket编程" class="headerlink" title="基于UDP协议的Socket编程"></a>基于UDP协议的Socket编程</h3><ul><li>创建发送端<ol><li>建立<code>DatagramSocket</code>对象。该端点建立，系统会随机分配一个端口。如果不想随机可以手动配置；</li><li>将数据进行<code>packet包</code>的封装，必须要指定目的地地址和端口；</li><li>通过<code>socket</code>服务的<code>send方法</code>将该包发出；</li><li>将socket关闭。</li></ol></li><li>创建接收端<ol><li>建立<code>DatagramSocket</code>对象。要监听一个端口；</li><li>通过<code>socket</code>的<code>receive方法</code>将数据存入数据包中；</li><li>通过数据包<code>dp</code>的方法<code>getData()</code>、<code>getAddress()</code>、<code>getPort()</code>等方法获取包中的指定信息。</li><li>将socket关闭。</li></ol></li></ul><h2 id="Annotation-注解"><a href="#Annotation-注解" class="headerlink" title="Annotation 注解"></a>Annotation 注解</h2><h3 id="Annotation-的原理"><a href="#Annotation-的原理" class="headerlink" title="Annotation 的原理"></a>Annotation 的原理</h3><ul><li>Annotation 是一种接口。通过Java<strong>反射机制</strong>中的相关API来访问Annotation 信息。相关类（框架或工具中的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。</li><li>Annotation 不会影响程序代码的执行。</li><li>Java语言解释器在工作时会忽略这些Annotation ，因此在JVM中这些Annotation 是“不起作用”的，只能通过配套的工具才能对这些Annotation 类型的信息进行访问和处理。Annotation 的工具统称<strong>APT</strong>。</li></ul><h3 id="常见的标准-Annotation"><a href="#常见的标准-Annotation" class="headerlink" title="常见的标准 Annotation"></a>常见的标准 Annotation</h3><ul><li><u>@Override</u>：用来指定方法重写，覆盖父类的方法。</li><li><u>@Deprecated</u>：用于表示某个程序元素（类、方法等）已过时。</li><li><u>@SuppressWarnings</u>：用于取消显示指定的编译器警告。</li></ul><h3 id="自定义-Annotation"><a href="#自定义-Annotation" class="headerlink" title="自定义 Annotation"></a>自定义 Annotation</h3><ul><li><p>自定义语法如下：</p><blockquote><p>访问修饰符 @interface Annotation名称 {</p><p>​ 返回类型 方法名() [default 默认值] ;</p><p>​ …</p><p>}</p></blockquote></li><li><p>特点：</p><ol><li>Annotation 类型使用的关键字<strong>@interface</strong> 不是interface。</li><li>Annotation 类型的方法必须声明为<strong>无参</strong>，<strong>无异常抛出</strong>的。</li><li>方法返回值类型必须为<strong>primitive类型</strong>、<strong>String类型</strong>、<strong>Class类型</strong>、<strong>枚举类型</strong>、<strong>annotation类</strong>型或前面类型之一作为元素的<strong>一维数组</strong>。</li><li>方法的后面可以使用default和一个默认数值来声明成员的默认值，<strong>null</strong>不能作为成员的默认值。</li><li>在定义Annotation 型态时，不能继承其他的Annotation 型态或是接口。</li></ol></li></ul><h2 id="Meta-Annotation-元注解"><a href="#Meta-Annotation-元注解" class="headerlink" title="Meta Annotation 元注解"></a>Meta Annotation 元注解</h2><ul><li><p>可以对Annotation 进行注解的注解。</p></li><li><p>标准Meta Annotation 有：@Retention、@Target、@Documented、@Inherited</p></li><li><p>@Retention ：</p><ul><li><p>作用：控制被@Retention注释的Annotation信息的<strong>保留时间长短</strong>。</p></li><li><p>语法结构：<code>@Retention(SOURCE/CLASS/RUNTIME)</code></p><ul><li>SOURCE：Annotation信息在编译阶段被丢弃，仅保留在Java源文件中。</li><li>CLASS：Annotation信息在编译阶段被保留，保留在class文件中，但运行阶段不存在。</li><li>RUNTIME：Annotation信息一直保留到运行阶段，直到退出虚拟机才被丢弃。</li></ul></li></ul></li><li><p>@Target:</p><ul><li><p>作用：表示的是一个Annotation的<strong>适用范围</strong>。</p></li><li><p>语法结构：<code>@Target({TYPE,METHOD,FIELD,···})</code></p><ul><li>TYPE：只能在类或接口或枚举上使用</li><li>FIELD：在成员变量上使用</li><li>METHOD：在方法中使用</li><li>PARAMETER：在参数上使用</li><li>CONSTRUCTOR：在构造中使用</li><li>LOCAL_VARIABLE：局部变量上使用</li><li>ANNOTATION_TYPE：只能在Annotation中使用</li><li>PACKAGE：只能在包中使用</li></ul></li></ul></li><li><p>@Documented：</p><ul><li>作用：制作JavaDoc文件的同时，也一并将Annotation的讯息加入到API文件中。</li></ul></li><li><p>@Inherited：</p><ul><li>作用：表示igeAnnotation是否允许被其子类继承下来。</li></ul></li></ul><h2 id="反射与-Annotation"><a href="#反射与-Annotation" class="headerlink" title="反射与 Annotation"></a>反射与 Annotation</h2><ul><li>一个Annotation真正起作用，必须结合反射机制，在<code>java.lang.reflect</code> 反射包中提供<code>AccessibleObject类</code>来对 Annotation 进行操作。</li><li>常用方法：<ul><li><strong>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotation)</strong>：判断是否使用指定的Annotation。</li><li><strong>getAnotations()</strong>：得到全部的Annotation。</li></ul></li><li>无反射，不注解。</li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/java基础（二）.html">java基础（二）</a></p><p><span>文章作者:</span><a href="/" title="访问 Mr.xiong 的个人博客">Mr.xiong</a></p><p><span>发布时间:</span>2019年11月03日 - 19:11</p><p><span>最后更新:</span>2019年11月15日 - 14:11</p><p><span>原始链接:</span><a href="/java基础（二）.html" title="java基础（二）">http://blog.xiongchang.vip/java基础（二）.html</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://blog.xiongchang.vip/java基础（二）.html" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div class="reward-container"><div>请作者喝咖啡</div><button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="http://imgs.xiongchang.vip/wx.png" alt="Mr.xiong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="http://imgs.xiongchang.vip/zfb.jpg" alt="Mr.xiong 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/SSM框架配置步骤.html" rel="next" title="SSM框架配置步骤"><i class="fa fa-chevron-left"></i> SSM框架配置步骤</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/HTML基础.html" rel="prev" title="HTML基础">HTML基础 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#反射"><span class="nav-text">反射</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多线程"><span class="nav-text">多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程特点"><span class="nav-text">多线程特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多线程目的"><span class="nav-text">多线程目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程模型"><span class="nav-text">线程模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建并运行线程"><span class="nav-text">创建并运行线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞和唤醒线程"><span class="nav-text">阻塞和唤醒线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死亡状态（Dead）"><span class="nav-text">死亡状态（Dead）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#终止线程的三种方法"><span class="nav-text">终止线程的三种方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程同步"><span class="nav-text">线程同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O框架"><span class="nav-text">I/O框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#递归算法"><span class="nav-text">递归算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流的分类"><span class="nav-text">流的分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节流"><span class="nav-text">字节流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符流"><span class="nav-text">字符流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他流"><span class="nav-text">其他流</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络编程"><span class="nav-text">网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI-七层参考模型"><span class="nav-text">OSI 七层参考模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-IP-模型"><span class="nav-text">TCP/IP 模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP地址"><span class="nav-text">IP地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#端口号"><span class="nav-text">端口号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见传输协议"><span class="nav-text">常见传输协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket"><span class="nav-text">Socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于TCP协议的Socket编程"><span class="nav-text">基于TCP协议的Socket编程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于UDP协议的Socket编程"><span class="nav-text">基于UDP协议的Socket编程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Annotation-注解"><span class="nav-text">Annotation 注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Annotation-的原理"><span class="nav-text">Annotation 的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的标准-Annotation"><span class="nav-text">常见的标准 Annotation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义-Annotation"><span class="nav-text">自定义 Annotation</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Meta-Annotation-元注解"><span class="nav-text">Meta Annotation 元注解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反射与-Annotation"><span class="nav-text">反射与 Annotation</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="http://imgs.xiongchang.vip/head.jpeg" alt="Mr.xiong"></a><p class="site-author-name" itemprop="name">Mr.xiong</p><div class="site-description" itemprop="description">日行一善</div></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=467567680&auto=0&height=66"></iframe><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xbrownbear" title="GitHub &rarr; https://github.com/xbrownbear" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1070375764@qq.com" title="E-Mail &rarr; mailto:1070375764@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://theme-next.org/docs/getting-started/" title="https://theme-next.org/docs/getting-started/" rel="noopener" target="_blank">Theme-nexT</a></li><li class="links-of-blogroll-item"><a href="https://www.google.com" title="https://www.google.com" rel="noopener" target="_blank">google</a></li><li class="links-of-blogroll-item"><a href="https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_66" title="https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_66" rel="noopener" target="_blank">TRHX</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Mr.xiong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">79k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">1:12</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5da135c42387c827" async></script></div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("10/01/2019 13:14:21");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span>访客量 <span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span>访问量 <span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.8" zindex="-1" count="300" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js?v=7.4.1.js"></script><script src="/js/motion.js?v=7.4.1.js"></script><script src="/js/schemes/pisces.js?v=7.4.1.js"></script><script src="/js/next-boot.js?v=7.4.1.js"></script><script src="/js/local-search.js?v=7.4.1.js"></script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'gXeDpwV5YvMCwOIWqpM23kRd-gzGzoHsz',
    appKey: 'P26X19DE4lLPJ3AqalUjTlVv',
    placeholder: '欢迎来踩......',
    avatar: 'hide',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);</script></body></html><script type="text/javascript" src="/js/src/love.js"></script><script type="text/javascript" src="/js/src/click_show_text.js"></script><canvas id="DigitalRain" width="1440" height="900"></canvas><script type="text/javascript" src="/js/src/DigitalRain.js"></script><script type="text/javascript" src="/js/src/FunnyTitle.js"></script><!-- rebuild by neat -->