<!-- build time:Tue Dec 03 2019 12:49:29 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 3.2.2"><script></script><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.4.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/bug-report-32x32.png?v=7.4.1"><link rel="icon" type="image/png" sizes="16x16" href="/images/bug-report-16x16.png?v=7.4.1"><link rel="mask-icon" href="/images/logo.svg?v=7.4.1" color="#222"><link rel="alternate" href="/atom.xml" title="一只不掉毛的程序猿" type="application/atom+xml"><link rel="stylesheet" href="/css/main.css?v=7.4.1"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css"><script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"7.4.1",exturl:!1,sidebar:{position:"left",display:"post",offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},translation:{copy_button:"复制",copy_success:"复制成功",copy_failure:"复制失败"},sidebarPadding:40}</script><meta name="description" content="基本概念java 关键字关键字"><meta property="og:type" content="article"><meta property="og:title" content="java基础（一）"><meta property="og:url" content="http://blog.xiongchang.vip/java基础（一）.html"><meta property="og:site_name" content="一只不掉毛的程序猿"><meta property="og:description" content="基本概念java 关键字关键字"><meta property="og:image" content="http://imgs.xiongchang.vip/img_35.png"><meta property="og:image" content="http://imgs.xiongchang.vip/img_32.png"><meta property="og:image" content="http://imgs.xiongchang.vip/img_34.png"><meta property="og:image" content="http://imgs.xiongchang.vip/img_33.png"><meta property="og:image" content="http://imgs.xiongchang.vip/img_41.png"><meta property="og:updated_time" content="2019-12-03T04:21:42.629Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="java基础（一）"><meta name="twitter:description" content="基本概念java 关键字关键字"><meta name="twitter:image" content="http://imgs.xiongchang.vip/img_35.png"><link rel="canonical" href="http://blog.xiongchang.vip/java基础（一）"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,isPage:!1,isArchive:!1}</script><title>java基础（一） | 一只不掉毛的程序猿</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><a href="https://your-url" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">一只不掉毛的程序猿</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-fw fa-sitemap"></i>站点地图</a></li><li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="http://blog.xiongchang.vip/java基础（一）.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Mr.xiong"><meta itemprop="description" content="日行一善"><meta itemprop="image" content="http://imgs.xiongchang.vip/head.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="一只不掉毛的程序猿"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">java基础（一）</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-03 11:47:26 / 修改时间：12:21:42" itemprop="dateCreated datePublished" datetime="2019-12-03T11:47:26+08:00">2019-12-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span> </a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span id="busuanzi_value_page_pv"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/java基础（一）.html#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/java基础（一）.html" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>13k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>11 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="java-关键字"><a href="#java-关键字" class="headerlink" title="java 关键字"></a>java 关键字</h3><ul><li><p>关键字<a id="more"></a></p><p><img src="http://imgs.xiongchang.vip/img_35.png" alt="http://imgs.xiongchang.vip/img_35.png"></p></li></ul><ul><li><p>this关键字：</p><ul><li>特点：<ol><li>在类的方法中使用的this关键字代表的是调用此方法的对象的引用；</li><li>this可以看做是一个变量，它的值是当前对象的引用；</li><li>使用this可以处理方法中的成员变量和形参同名的问题；</li><li>当在方法内需要用到调用该方法的对象时，就可以用this；</li><li>在类的构造方法中可以调用<code>this（[参数列表]）</code>来调用该类的指定构造方法。</li></ol></li></ul></li><li><p>static关键字：</p><ul><li><p>特点：</p><ol><li><p>用来修饰类的成员—修饰成员变量\方法的称之为类变量\方法（静态变量\方法）;</p></li><li><p>当类被加载的时候会被加载，优先于对象的存在；</p></li><li><p>用来修饰语句块—称之为静态代码块。先于构造方法之前执行，只执行一次，用来对静态成员做初始化；</p></li><li><p>静态修饰的成员被所有的对象共享；</p></li><li><p>调用的时候开业直接通过<code>类名.成员</code>来进行访问。</p></li></ol></li><li><p>注意事项：</p><ol><li>静态方法中只能访问外部的静态成员；</li><li>静态方法中不能出现this关键字；</li><li>非静态方法中可以访问静态的内容和非静态的属性和方法。</li></ol></li></ul></li><li><p>final关键字：</p><ul><li>特点：<ol><li>final可以用来修饰变量、方法、类；</li><li>final修饰的变量是一个常量，一旦赋值就不能再修改；</li><li>常量一般都和static关键字（静态）配合使用；</li><li>final修饰方法代表次方法不能被重写；</li><li>final修饰类代表此类不能被继承。</li></ol></li></ul></li></ul><h3 id="java-面向对象"><a href="#java-面向对象" class="headerlink" title="java 面向对象"></a>java 面向对象</h3><ul><li><p>面向对象编程的特性：</p><ol><li>万物皆对象；</li><li>程序是一组对象彼此之间在发送消息；</li><li>每个对象都有自己的内存占用，可以组装成更大对象；</li><li>每个对象都有类型，特定类型的所有的对象可以接受相同消息。</li></ol></li><li><p>类和对象的概念、区别和联系：</p><ul><li><p>概念：</p><ul><li><p>类（抽象的概念）：类是创建对象的模板和蓝图；类是一组类似对象的共同抽象定义。</p></li><li><p>对象：对象的类的实例化结果；对象是实实在在存在的，代表现实世界的某一事物。</p><p>对象的两个关键特性：<strong>行为</strong>（对象能干什么。例：猫抓老鼠）；<strong>状态</strong>（对象的属性，行为的结果）</p></li></ul></li><li><p>区别：</p><ol><li>类是静态定义，对象是动态实例；</li><li>程序代码操作的是对象而非类；</li><li>建模得到的是类而非对象。</li></ol></li><li><p>联系：</p><ol><li>类是对象的定义；</li><li>对象的产生离不开类这个模板；</li><li>类存在的目的是实例化得到对象。</li></ol></li></ul></li><li><p>java对象的内存管理机制：</p><ul><li>使用new创建对象，在堆内存分配对象空间，初始化；</li><li>在方法栈中定义局部变量，持有对堆内存中对象的引用；</li><li>方法执行完返回，栈内存自动释放，局部变量销毁；</li><li>如果堆内存中对象没有变量引用它，成为垃圾，由垃圾回收器回收，释放所占堆内存。</li><li>java垃圾回收器：<ul><li>java运行时系统有一个垃圾回收线程负责清除（堆内存空间）不再使用的对象，俗称垃圾回收器。</li><li>垃圾回收器定期扫描内存，对于被使用的对象加上标记，按可能的路径扫描结束后清除未加标记的对象。</li><li>被回收的对象：<ol><li>不再被任何变量引用的对象；</li><li>引用变量自动废弃；</li><li>人为将引用变量置为空（null）。</li></ol></li></ul></li></ul></li><li><p>多态</p><ul><li><p>概念：</p><ul><li><p>多态性是指同一操作作用于某一类对象，可以有不同的解释，产生不同的执行结果；</p></li><li><p>多态存在的三个必要条件【重点】：</p><ol><li><p>需要存在继承和实现关系；</p></li><li><p>同样的方法调用而执行不同操作、运行不同代码；（重写操作）</p></li><li><p>在运行时父类或者接口的引用变量可以引用其子类的对象。</p><p>（例：<code>Animal A = new Dog(); //其中Dog类继承Animal类</code>）</p></li></ol></li></ul></li><li><p>多态作用：</p><ul><li>多态通过分离做什么和怎么做，从另一个角度将接口和实现进行分离；</li><li>“多态”则消除了类型之间的耦合关系；</li><li>多态的存在提高了程序的扩展性和后期的可维护性。</li></ul></li></ul></li><li><p>继承：</p><ul><li>继承需要符合的关系：is-a，父类更通用更抽象，子类更特殊更具体。</li><li>继承背后的思想就是基于已存在的类（父类）来构建新类（子类）；</li><li>子类可以重用父类的方法和属性，还可以添加新的方法和属性；</li><li>约定：从其他类导出的类叫子类，被导出的类叫父类；</li><li>在java中，除了Object类之外，所有类都是子类，都有唯一的父类；</li><li><p>继承的意义：</p><ol><li>代码重用</li><li>体现不同抽象层次</li></ol></li><li><p>父子类关系：</p><ol><li>父类更抽象，更一般</li><li>子类更具体，更特殊</li></ol></li></ul></li><li><p>封装</p><ul><li><p>将东西包装在一起，然后以新的完整形式呈现出来；</p><p>将方法和字段（属性）一起包装到一个单元里，单元以类的形式实现。</p></li><li><p>信息隐藏，隐藏对象的现实细节，不让外部直接访问到；</p></li><li><p>将数据和方法包装进类中，加上具体实现的隐藏，共同被称作封装，</p><p>其结果是一个同事带有特征和行为的数据类型。</p></li><li><p>定义类，定义其属性、方法的过程称为封装类。</p></li><li><p>信息隐藏是OOP最重要的功能之一，也是使用访问修饰符的原因；</p></li><li><p>信息隐藏的原因包括：</p><ol><li>对模块的任何实现细节所作的更改不会影响使用该模块的代码；</li><li>防止用户意外修改数据；</li><li>使模块易于使用和维护。</li></ol></li><li><p>封装方法的目的：隐藏了细节，实现了简化调用，有利于修改维护。</p></li></ul></li><li><p>访问修饰符：</p></li></ul><table><thead><tr><th>位置</th><th>private</th><th>默认</th><th>protected</th><th>public</th></tr></thead><tbody><tr><td>同一个类</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一个包中的类</td><td>×</td><td>√</td><td>√</td><td>√</td></tr><tr><td>不同包中的类</td><td>×</td><td>×</td><td>√</td><td>√</td></tr><tr><td>不同包且不是子类</td><td>×</td><td>×</td><td>×</td><td>√</td></tr></tbody></table><ul><li><p>方法重载</p><ul><li><p>方法重载是的在一个类中，方法名相同而参数列表不同的方法可同时存在，代表相似的行为或功能</p></li><li><p>概念：同一类中，同名不同参（个数、类型）的方法称为重载方法</p></li><li><p>注意：仅返回类型不同的方法不能称为重载，即方法重载必须【方法签名】不同。</p></li></ul></li><li><p>方法重写</p><ul><li><p>方法重写是指子类可以根据需要对从父类继承的方法进行改写，是多态机制的前奏</p></li><li><p>注意：</p><ol><li>重写方法必须和被重写方法具有相同的【方法名称】、【参数列表】和【返回值】；</li><li>重写方法不能使用比被重写方法更严格的访问权限（<strong>重写方法权限&lt;=被重写方法权限</strong>）；</li><li>父类中的私有方法（private）不能被重写；</li><li>在子类重写的方法中继续调用父类被重写的方法可以通过调用 <code>super.函数名</code> 获取。</li></ol></li></ul></li><li><p>抽象类概念和作用：</p><ul><li>抽象的定义：抽象是把多个事物的共性抽取出来，本质就是把我们关注的内容抽取出来。</li><li>抽象类：java中可以定义没有方法体的方法，该方法由其子类具体的实现；</li><li>该没有方法体的方法称之为抽象方法，含有抽象方法的类称之为抽象类。</li><li>抽象方法特点：<ol><li>只有方法头没有方法体的方法称为抽象方法；</li><li>抽象方法用abstract来修饰；</li><li>抽象方法代表一种不确定的操作或行为；</li><li>抽象方法不能被调用。</li></ol></li><li>抽象类特点：<ol><li>含有抽象方法的类称之为抽象类；</li><li>抽象类用abstract来修饰；</li><li>抽象类代表一种抽象的对象类型；</li><li>抽象类不能实例化；</li><li>抽象类中可以有具体方法，可以有抽象方法。</li></ol></li></ul></li><li><p>接口概念和作用：</p><ul><li>特点：<ol><li>接口中只能存放静态常量和抽象方法；</li><li>java接口是对功能的扩展；</li><li>通过实现接口，java类可以实现多实现（一个可以多接口）</li><li>一个类可以同时继承（extends）一个父类并且实现（implements）多个接口；</li><li>接口与接口之间可以通过使用extends来产生继承关系。（不能用implements）。</li></ol></li></ul></li><li><p>接口和抽象类的区别：</p><ol><li><p>抽象类和具体实现类之间是一种继承关系，也就是说如果采用抽象类方式，则父类和子类在概念上应该是相同的</p></li><li><p>接口和实现类在概念上不要求相同，接口只是抽取相互之间没有关系的类的共同特征，而不去关注类之间的关系，它可以使没有层次关系的类具有相同的行为；</p></li><li><p>抽象类是对一组具有相同属性和行为的逻辑上有关系的事物的一种抽象，而接口则是对一组具有相同属性和行为的逻辑上不相关的事物的一种抽象；</p></li><li><p>对于接口和抽象类的选择，反映出设计人员看待问题的不同角度。</p><p>抽象类用于一组相关的事物，表示的是“is-a”的关系；</p><p>接口用于一组不相关的事物，表示的是“like-a”的关系（可翻译成具备）</p></li></ol></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>一维数组：</p><ul><li><p>作用：存储相同数据类型的一组数据；对同类型数据进行集中管理，比如储存和遍历。</p></li><li><p>声明创建：数据类型[] 数组名 = new 数据类型[大小]；（int[] a=new int[10];）</p></li><li><p>数组的初始化（赋值）：</p><ol><li><p>边声明边赋值（静态初始化）；</p><p><code>int[] score={66,77,88};&lt;=&gt;int[] score=new int[]{66,77,88};</code></p></li><li><p>动态的获取（键盘录入）信息并赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] score=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</div><div class="line">Scanner input=<span class="keyword">new</span> Scanner(System.in);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">score[i]=input.nextInt();</div></pre></td></tr></table></figure></li></ol></li><li><p>java API（应用程序接口）:包装好的类；API就是操作系统留给应用程序的一个调用接口，应用程序通过调用操作系统的 API 而使操作系统去执行应用程序的命令。</p></li></ul></li><li><p>二维数组：</p><ul><li><p>声明创建：<code>数据类型[][] 数组名 = new 数据类型[大小][大小（可空）]；</code>（举例：<code>int[][] a=new int[10][];</code>）</p></li><li><p>数组的初始化（赋值）：</p><ol><li><p>边声明边赋值（静态初始化）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> [][] a=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</div></pre></td></tr></table></figure></li><li><p>动态的获取（键盘录入）信息并赋值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">String  array=<span class="keyword">new</span> String3;    <span class="comment">//声明、创建、分配内存</span></div><div class="line">array[<span class="number">0</span>]=<span class="keyword">new</span> String[<span class="number">2</span>];        <span class="comment">//高维给低维分配空间</span></div><div class="line">array[<span class="number">1</span>]=<span class="keyword">new</span> String[<span class="number">3</span>];</div><div class="line">array[<span class="number">2</span>]=<span class="keyword">new</span> String[<span class="number">4</span>];</div><div class="line">array0=<span class="keyword">new</span> String (<span class="string">"1"</span>);    <span class="comment">//赋值</span></div></pre></td></tr></table></figure></li></ol></li></ul></li></ul><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="内部类的特点"><a href="#内部类的特点" class="headerlink" title="内部类的特点"></a>内部类的特点</h3><ol><li>内部类可以很好的实现隐藏，可以使用protected、private修饰符；</li><li>内部类可以直接访问外部类的所有成员，包括私有的成员；</li><li>外部类不能直接访问内部类的成员，必须首先要建立内部类的对象才能访问；</li><li>内部类可以解决一些问题，比如间接的去实现多继承。；</li><li>可以避免修改接口而实现同一个类中两种同名方法的调用。</li><li>内部类有四类：成员内部类、匿名内部类、静态内部类、局部内部类。前两个用的较多。</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><ul><li><p>特点：</p><ul><li>成员内部类属于外部类的实例成员，成员内部类可以有public、private、default、protected权限修饰符。在成员内部类中访问外部类的成员方法和属性，要使用<code>外部类名.this.成员方法</code>和<code>外部类名.this.成员属性</code>的形式。</li><li>创建成员内部类的实例使用<code>外部类名.内部类名 实例名=外部类实例名.new 内部类构造方法（参数）</code>的形式。</li></ul></li><li><p>限制：</p><ul><li>成员内部类不能与外部类重名；</li><li>不能在成员内部类中定义static型的属性、方法和类（static final形式的常量定义除外）因为一个成员内部类实例必然与一个外部类实例关联，static成员完全可以移到其外部类中.</li></ul></li></ul><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><ul><li><p>特点：</p><ul><li>使用static修饰的成员内部类叫静态内部类</li><li>静态内部类跟外部类没有任何关系，只是在生成类名和类定义时有影响。静态内部类可以看做是与外部类平级的类。使用方法与外部类平级的类完全相同</li><li>创建静态内部类的实例使用：<code>外部类名.内部类名 实例名 = new 外部类名.内部类名（参数）;</code></li></ul></li><li><p>限制：</p><ul><li>静态内部类不能与外部类同名；</li><li>静态内部类不能访问外部类的非静态的属性和方法，外部类不能访问内部类的非静态的属性和方法。</li></ul></li></ul><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><ul><li><p>特点：</p><ul><li>匿名内部类是没有名称的内部类，没办法引用它们。必须在创建时，作为new语句的一部分来声明并创建它们的实例</li><li>匿名内部类必须继承一个类（抽象的、非抽象的都可以）或者实现一个接口。如果父类（或者父接口）是抽象类，则匿名内部类必须实现其所有抽象方法</li><li>匿名内部类中可以定义代码块，用于实例的初始化，但是不能定义静态代码块</li></ul></li><li><p>语法：</p><ul><li><code>new interface/superclass(){//类体}</code></li><li>这种形式的new语句声明一个新的匿名类，它对一个给定的类进行扩展，或者实现一个给定的接口，并同时创建该匿名类的一个新实例.</li></ul></li></ul><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><ul><li><p>特点：</p><ul><li>定义在代码块、方法体的类叫局部内部类</li><li>局部内部类访问外部类的属性和方法形式：<code>外部类名.this.属性名”和“外部类名.this.方法名（参数）</code></li><li>对外部世界完全隐藏，只能在其作用域内生成对象</li></ul></li><li><p>限制：</p><ul><li>局部内部类不能加访问修饰符，因为它们不是类成员</li><li>局部内部类不能与外部内部类重名</li><li>局部内部类访问作用域内的局部变量，该局部变量需要使用final修饰</li></ul></li></ul><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><ul><li>enum很想特殊的class，实际上enum声明定义的类型就是一个类；</li><li>这些类都是类库中Enum类的子类（java.lang.Enum<e>），它们继承了Enum中许多有用的方法</e></li><li>枚举值都是public static final的，也就是常量，因此枚举类中的枚举值应全部大写</li><li><p>枚举类型是class，在枚举类型中有构造器，方法和字段，但枚举的构造器有很大的不同：</p><ul><li>构造器只是在构造枚举值的时候被调用；</li><li>构造器私有private，不允许有public构造器。</li></ul></li><li><p>枚举可以在switch语句中使用。</p></li></ul><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><ul><li>java语言中的字符串值属于String类，虽然有其他方法表示字符串（如字符数组），但java一般使用String类作为字符串的标准格式，java编译器把字符串值作为String对象；</li><li>String对象一旦创建就不能改变。如果需要进行大量的字符串修改操作，应该使用StringBuffer/StringBuilder类或者字符数组，最终结果可以被转换成String对象。</li></ul><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><ul><li>StringBuffer线程安全的可变字符序列；</li><li>一个类似于String的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容；</li><li>每个字符串缓冲区都有一定的容量，只要字符串缓冲区所包含的字符序列的长度没有超过此容量，就无需分配新的内部缓冲区数组；</li><li>如果内部缓冲区溢出，则此容量自动增大。</li></ul><h3 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h3><ul><li>从jdk 5开始，为StringBuffer类补充了一个单个线程使用的等价类；</li><li>与StringBuffer相比，通常优先使用StringBuilder类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。</li></ul><h3 id="Date日期类、SimpleDateFormat类"><a href="#Date日期类、SimpleDateFormat类" class="headerlink" title="Date日期类、SimpleDateFormat类"></a>Date日期类、SimpleDateFormat类</h3><ul><li>Date表示特定的时间，精确到毫秒；</li><li>DateFormat是日期/时间格式化抽象类，它以与语言无关的方式格式化并分析日期或时间；日期/时间格式化子类（如：SimpleDateFormat）允许进行格式化（也就是日期-&gt;文本），分析（文本-&gt;日期）</li></ul><h3 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h3><ul><li><p>是一个抽象类，为特定瞬间与一组诸如YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。瞬间可用毫秒值来表示，它是距历元（即格林威治标准时间1970年1月1日的00:00:00.000）的偏移量；</p></li><li><p>与其他语言环境敏感类一样，Calendar提供了一个类方法getInstance，以获得此类型的一个通用的对象。Calendar的getInstance方法返回一个Calendar对象，其日历字段已由当前日期和时间初始化；</p></li><li>protected受保护的，不能new出来。</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><table><thead><tr><th>异常类型</th><th>包括</th><th>来源</th><th>处理</th></tr></thead><tbody><tr><td>受查异常</td><td>Exception及其子类（不包括RuntimeException及其子类）</td><td>由代码控制能力之外的因素导致的运行错误</td><td>必须要处理，否则无法通过编译</td></tr><tr><td>非受查异常</td><td>Error和RuntimeException及其子类</td><td>RuntimeException一般代表编程错误</td><td>可以不用处理</td></tr></tbody></table><ul><li><p>java异常处理机制：</p><ul><li><p>java的异常是通过两种机制来处理的：</p><ul><li><p>捕获：<code>try...catch...finally</code></p><p>try -&gt; 监控区域，执行可能产生异常的代码</p><p>catch -&gt; 捕获、处理异常</p><p>finally -&gt; 善后处理，无论是否有异常，都执行此代码，除了在之前执行了<code>System.exit(0);</code>（退出程序），一般用来释放资源，</p></li><li><p>抛出：<code>throw、throws</code></p><p>throw -&gt; 手动抛出异常（任何位置）</p><p>throws -&gt; 标识声明方法可能要抛出的异常（修饰方法）</p><p>二者区别：</p><p>throw用在方法内，后面跟上要抛出的异常类对象</p><p>throws修饰在方法上，告诉调用者此方法可能会抛出异常，后面跟上可能要抛出的异常类名。</p></li></ul></li></ul></li><li><p>自定义异常：</p><ul><li><p>常见异常：RuntimeException（非受查异常）、IOException（受查异常）、SQLException（受查异常）、ClassNotFoundException（受查异常）</p></li><li><p>自定义异常：</p><ul><li>java提供的异常体系不可能预见所有希望加以报告的错误；</li><li>自定义异常类必须从已有的异常类继承；</li><li>建立新的异常类型最简单的方法就是让编译器产生默认构造方法；</li><li>对异常来说，最重要的部分就是它的类名</li><li>可以为异常类定义一个接收字符串参数的构造方法，字符串参数描述异常信息。</li></ul></li></ul></li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><ul><li><p>所谓泛型，即通过参数化类型来实现在同一份代码上操作多种数据类型，泛型编程是一种编程范式，它利用“参数化类型”将类型抽象化，从而实现更为灵活的复用。</p></li><li><p>泛型类</p><ol><li>泛型的类型参数可以是泛型类</li><li>泛型类可以同时设置多个类型参数</li><li>泛型类可以继承泛型类</li><li>泛型类可以实现泛型接口</li></ol></li><li><p>限制泛型可用类型：</p><ul><li>在定义泛型类别时，默认在实例化泛型类的时候可以使用任何类型，但如果想要限制使用泛型类别时，只能用某个特定类型或者是其子类型才能实例化该类型，可以在定义类型时，使用【extends】关键字指定这个类型必须是继承某个【类】，或者实现某个【接口】；</li><li>当没有指定泛型继承的类型或接口时，默认使用<code>extends Object</code>，所以默认情况下任何数据类型都可以作为参数传入。</li></ul></li><li><p>泛型通配的方式：</p><ul><li><p><code>?</code> 代表任意一个类型；</p><p><code>Gen&lt;Boolean&gt; g1=new Gen&lt;Boolean&gt;();</code></p><p><code>Gen&lt;?&gt; g=g1;</code></p></li><li><p>和限制泛型的上限相似，同样可以使用extends关键字限定通配符匹配类型的上限；</p><p><code>Gen&lt;Dog&gt; g1=new Gen&lt;Dog&gt;();</code></p><p><code>Gen&lt;? extends Animal&gt; g=g1;</code></p></li><li><p>还可以使用super关键字将通配符匹配类型限定为某个类型及其父类型（下限）</p><p><code>Gen&lt;Animal&gt; g1=new Gen&lt;Animal&gt;();</code></p><p><code>Gen&lt;? super Dog&gt; g=g1;</code></p></li></ul></li><li><p>泛型方法</p><ul><li>不仅类可以声明泛型，类中的方法也可以声明仅用于自身的泛型，这种方法叫做泛型方法(与普通方法相比多一个<code>&lt;泛型列表&gt;</code>)</li><li>在泛型列表中声明的泛型，可用于该方法的返回类型声明、参数类型声明和方法代码中的局部变量的类型声明；</li><li>类中其他方法不能使用当前方法声明的泛型。（提示：是否拥有泛型方法，与其所在的类是否泛型没有关系。要定义泛型方法，只需要泛型参数列表至于返回类型前）</li><li>什么时候<strong>使用泛型方法</strong>，而不是泛型类呢？<ul><li>添加类型约束只作用与一个方法的多个参数之间、而不涉及到类中的其他方法时；</li><li>施加类型约束的方法为静态方法，只能将其定义为泛型方法，因为静态方法不能使用其所在类的类型参数</li></ul></li></ul></li></ul><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="集合框架-1"><a href="#集合框架-1" class="headerlink" title="集合框架"></a>集合框架</h3><ul><li><p>所谓的框架就是一个类库的集合。集合框架就是一个用来表示和操作集合的统一架构，它包含了实现集合的接口和类；</p></li><li><p>集合框架中不同的集合类有各自不同的数据结构，所以在使用中要根据应用的性能要求选择不同的集合类；</p></li><li><p>集合类存放在java.util包中。</p><p><img src="http://imgs.xiongchang.vip/img_32.png" alt="http://imgs.xiongchang.vip/img_32.png" style="zoom:80%"></p></li><li><p>Iterable接口：</p><ul><li><p>实现该接口允许对象成为“foreach”语句的目标，即该集合对象允许迭代；</p></li><li><p>类集接口Collection是Iterable的子接口，所以所有类集对象可以迭代访问，而映射Map不行；</p></li><li><p>方法：</p><p><code>Iterable&lt;T&gt; iterator()</code></p></li><li><p>功能：返回一个在一组T类型的元素上进行迭代的迭代器</p></li><li><p>迭代器是实现了Iterator/ListIterator接口的类的对象，可以通过遍历类集，访问操作其中的每个元素；</p></li><li><p>ListIterator扩展了父接口Iterator（单向遍历），允许双向遍历集合，并可以修改和删除元素。</p></li></ul></li><li><p>Collection接口：</p><ul><li><p>类集Collection接口定义的方法：</p><p><code>int size()</code></p><p><code>boolean isEmpty()</code></p><p><code>boolean contains(Object o)</code></p><p><code>Iterator&lt;E&gt; iterator()</code></p><p><code>Object[] toArray()</code></p><p><code>boolean add(E e)</code></p><p><code>boolean remove(Object o)</code></p><p><code>void clear()</code></p></li></ul></li><li><p>List、Set、Map接口：</p><ul><li>List：接口扩展了Collection，特点：有序且可重复的</li><li>Set ：接口扩展了Collection，特点：无序且不可重复的</li><li>Map ：映射是一个存储关键字/值对的对象。给定一个关键字，可查询得到它的值，关键字和值都可以是对象。映射不是Collection的子接口。所以它本身不能使用迭代器来进行遍历。</li></ul></li></ul><h3 id="List-容器特点"><a href="#List-容器特点" class="headerlink" title="List 容器特点"></a>List 容器特点</h3><ul><li><p><strong>有序且可重复</strong>的（包括NULL），通过整数索引来访问；</p></li><li><p>最常见的两个List接口实现类是<code>ArrayList</code>和<code>LinkedList</code>。</p><ul><li><p>ArrayList：</p><ul><li>动态数组：自动扩容</li><li>ArrayList类扩展AbstractList并实现了List接口</li><li>支持可随需增长的动态数组</li></ul></li><li><p>LinkedList：</p><ul><li>链表</li><li>LinkedList 类扩展<code>AbstractSequentialList</code>并<strong>实现List接口</strong>；</li><li>LinkedList 提供了一个链表数据结构，可将链接列表用于<strong>堆栈</strong>，<strong>队列</strong>，<strong>双端队列</strong>；</li></ul></li><li><p><code>ArrayList</code>和<code>LinkedList</code>：</p><p><img src="http://imgs.xiongchang.vip/img_34.png" alt="http://imgs.xiongchang.vip/img_34.png" style="zoom:80%"></p></li></ul></li></ul><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><ul><li><p>映射（map）是一个存储键/值对的对象。给定一个键，可查询得到它的值，键和值都是对象</p></li><li><p>键必须是唯一的，值可以重复；</p></li><li><p>有些映射可以接受NULL键和NULL值，而有的不行；</p></li><li><p>下面的接口支持映射：</p></li></ul><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>Map</td><td>映射唯一关键字给值</td></tr><tr><td>Map.Entry</td><td>描述映射中的元素（关键字/值对）。这是Map的一个内部类</td></tr><tr><td>SortedMap</td><td>扩展Map以便关键字按升序保持</td></tr></tbody></table><ul><li><p>Map接口映射<strong>唯一</strong>键到值</p></li><li><p><strong>键（key）</strong>是以后用于检索值的对象。给定一个键和一个值，可以存储这个值到一个Map对象中，以为可以使用对应键检索它</p></li><li><p>Map 族谱：</p><p><img src="http://imgs.xiongchang.vip/img_33.png" alt="http://imgs.xiongchang.vip/img_33.png" style="zoom:80%"></p></li><li><p>Map接口定义的方法：</p><p><code>int size()</code>：获取键值对个数</p><p><code>boolean isEmpty()</code></p><p><code>boolean containsKey(Object key)</code>：判断是否包含该键</p><p><code>boolean containsValue(Object value)</code>：判断是否包含该值</p><p><code>V get(Object key)</code>：根据键得到值</p><p><code>V put(K key,V value)</code>：把键值对数据添加到容器当中</p><p><code>V remove(Object key)</code>：删除键</p><p><code>Collection&lt;V&gt; values()</code>：获取Map容器中所有的值</p><p><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：返回包含的映射关系的Set视图</p></li><li><p>Map.Entry接口：</p><ul><li><p>Map.Entry接口代表映射项（键-值对）类型，是Map的嵌套类型</p></li><li><p>Map接口定义的entrySet()方法返回包含映射项Entry的集合（Set），集合中元素是Map.Entry类型</p></li><li><p>Map.Entry接口定义的方法</p><p><code>K getKey()</code>：得到键</p><p><code>V getValue()</code>：得到值</p><p><code>V setValue()</code>：设置值</p></li></ul></li><li><p>HashMap类：</p><ul><li><p>HashMap类是基于哈希表的map接口的实现，并允许使用NULL键和NULL值</p></li><li><p>构造方法：</p><p><code>HashMap()</code>：默认初始容量16，加载因子0.75</p><p><code>HashMap(Map m)</code></p><p><code>HashMap(int capacity)</code>：自定义初始容量，默认加载因子为0.75</p><p><code>HashMap(int capacity,float fillRatio)</code>：自定义初始容量，填充因子（一般0.75）</p></li><li><p>HashMap<strong>实现Map</strong>并扩展<code>AbstractMap</code>，本身并没有增加任何新的方法</p></li><li><p>散列映射不保证它的元素的顺序，元素加入散列映射的顺序并不一定是它们被迭代读出的顺序。</p></li></ul></li><li><p>TreeMap类：</p><ul><li><p>TreeMap类通过使用红黑树实现Map接口；</p></li><li><p>TreeMap提供按排序顺序存储键值对的有效手段，同时允许快速检索不像散列映射，树映射保证它的元素按关键字升序排列；</p></li><li><p>TreeMap实现<code>SortedMap接口</code>并且扩展<code>AbstractMap</code>，它本身并没有定义其他方</p><ul><li>Comparator和Comparable接口</li><li>TreeMap的key存储引用类型数据，需要满足一定条件：<ul><li>要么引用类型实现Comparable；</li><li>要么为该TreeMap容器提供实现Comparator接口的比较器对象。</li></ul></li></ul></li></ul></li></ul><h3 id="Set容器"><a href="#Set容器" class="headerlink" title="Set容器"></a>Set容器</h3><ul><li>特点：<ul><li>Set容器是一个不包含重复元素的Collection，并且最多包含一个null元素，它和List容器相反，Set容器不能保证其元素的顺序；</li></ul></li><li>HashSet：<ul><li>HashSet扩展AbstractSet并且实现Set接口；</li><li>HashSet使用散列表（哈希表）进行存储；</li><li>HashSet没有定义任何超过它的父类和接口提供的其他方法；</li><li>散列集合没有确保其元素的顺序，因为散列处理通常不参与排序。</li></ul></li><li>TreeSet：<ul><li>TreeSet为使用树来进行存储的Set接口提供了一个工具，对象按升序存储，访问和检索很快；</li><li>在存储了大量的需要进行快速检索的排序信息的情况下，TreeSet是一个很好的选择；</li><li>注意：TreeSet的内部操作的底层数据是<code>TreeMap</code>，只是我们<strong>操作的是TreeMap的key</strong>。</li></ul></li></ul><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><ul><li><p>Collections类集工具箱，定义了若干用于类集合映射的算法，这些算法被定义为静态方法，常用方法如下：</p><p><code>public static void sort(List&lt;T&gt; list)</code>：自然排序</p><p><code>public static int binarySearch(List&lt;T&gt; list,T key)</code>：二分法查找</p><p><code>public static void reverse(List&lt;?&gt; list)</code>：逆置</p><p><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱顺序</p><p><code>public static void swap(List&lt;?&gt; list,int i,int j)</code>：交换顺序</p><p><code>public static &lt;T&gt; void fill(List&lt;? super T&gt; list,T obj)</code>：填充</p></li><li><p>专门为Collection接口的实现类和Map接口的实现类服务。</p></li></ul><h2 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h2><ul><li>在java语言中，JFC是开发GUI的API集，它<strong>主要</strong>包含以下几个部分：<ol><li>AWT（抽象窗口工具包）：java开发用户界面最初的工具包，是建立JFC的主要基础；</li><li>Swing组件，建立在AWT之上，新的、功能更强大的图形组件包；</li><li>java 2D：实现高质量的二维图形；</li></ol></li></ul><h3 id="AWT框架"><a href="#AWT框架" class="headerlink" title="AWT框架"></a>AWT框架</h3><ul><li><p>在<code>java.awt</code>包中包含了一个完整的类集以支持GUI程序的设计（可称为重量级，依赖于本地平台）</p><p><img src="http://imgs.xiongchang.vip/img_41.png" alt="http://imgs.xiongchang.vip/img_41.png"></p></li><li><p>Component类是最核心的类，它是构成java图形用户界面的基础，大部分组件都是由该类派生出来的</p></li><li><p>Component类主要由基本组件和容器（Container）组件组成；</p></li><li><p>容器（Container）组件主要分为：<strong>Window容器</strong>和<strong>Panel容器</strong>。</p></li></ul><h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><ul><li><p>容器内可以存放各种组件，而组件的位置和大小是由容器内的布局管理器来决定。</p><ul><li><p>在AWT中为我们提供了5种布局管理器：</p><p>FlowLayout流式布局管理器</p><p>BorderLayout边界布局管理器</p><p>GridLayout网络布局管理器</p><p>CardLayout卡片布局管理器</p><p>GridBagLayout网络包布局管理器</p></li></ul></li><li><p>容器中组件的布局通常由布局管理器控制。每个Container（比如一个Panel或一个Farmer）都有一个与它相关的缺省布局管理器，Panel容器默认的是FlowLayout，Farmer容器默认的是BorderLayout，我们可以通过调用setLayout()来改变布局管理器。</p></li><li><p>我们可以通过设置空布局管理器，来控制组件的大小和位置，可调用<code>setLayout（null）</code></p></li><li><p>在设置空布局管理器后，必须对所有的组件调用<code>setLocation（）</code>，<code>setSize（）</code>或<code>setBounds（）</code>将他们定位在容器中。</p></li></ul><h3 id="AWT事件处理基本概念"><a href="#AWT事件处理基本概念" class="headerlink" title="AWT事件处理基本概念"></a>AWT事件处理基本概念</h3><ul><li><p>AWT事件的处理过程中，主要涉及3类对象：</p><ul><li><p>Event（事件）：用户对组件的一个操作，称之为一个事件，以类的形式出现，</p><p>例如：键盘操作对应的事件类是KeyEvent。其实例在该事件发生时由系统自动产生。每一种事件都对应专门的监听者</p></li><li><p>Event Source（事件源）：事件发生的场所，通常就是各个组件，例如：按钮Button。</p></li><li><p>Event Monitor（事件监听器）：接收事件对象并对其进行处理的类的对象，通常其中某个成员方法对事件进行相应的处理。</p></li><li><p>注意：java采取了事件委托处理模型，事件源自己不处理事件，而是把在其自身所有可能发生的事件委托给事件监听器来处理。</p></li></ul></li><li><p>事件：</p><ul><li><p>AWT的相关事件继承与java.awt.AWTEvent类，这些事件分为两大类：低级事件和高级事件低级事件是指基于组件和容器的事件，当一个组件发生事件</p><p><code>ComponentEvent</code> 组件事件：组件尺寸的变化、移动</p><p><code>ContainerEvent</code> 容器事件：组件增加、移动</p><p><code>WindowEvent</code> 窗口事件：关闭窗口、窗口闭合、图标化</p><p><code>FocusEvent</code> 焦点事件：焦点的获得和丢失</p><p><code>KeyEvent</code> 键盘事件：键按下、释放</p><p><code>MouseEvent</code> 鼠标事件：鼠标单击、移动</p></li><li><p>高级事件是基于语义的事件，它可以不和特定的动作相关联，而依赖于触发此事件的类</p><p><code>ActionEvent</code> 动作事件：按下，TextField中按Enter键</p><p><code>AdjustmentEvent</code> 调节事件：在滚动条上移动滑块以调节数值</p><p><code>ItemEvent</code> 项目事件：选择项目，不选择“项目改变”</p><p><code>TextEvent</code> 文本事件：文本对象改变</p></li></ul></li><li><p>事件监听器：</p><ul><li><p>事件监听器通常是一个类，该类必须实现与该事件类型相对应的接口，对应的接口被称为事件监听器接口。事件监听器接口类的名称与事件类的名称相对应</p><p>例：MouseEvent对应监听器MouseListener</p></li></ul></li><li><p>事件适配器类：</p><ul><li><p>java语言为一些事件监听接口提供了适配器类（Adapter）。我们可以通过继承事件所对应的Adapter类，重写所需要的方法，无关的方法则不用实现。事件适配器为我们提供了一种简单的实现监听器的手段，可以缩短程序代码。</p></li><li><p>java.awt.event包中定义的事件适配器类包括以下七个：</p><p><code>MouseAdapter</code>：鼠标适配器</p><p><code>MouseMotionAdapter</code>：鼠标运动适配器</p><p><code>KeyAdapter</code>：键盘适配器</p><p><code>WindowAdapter</code>：窗口适配器</p><p><code>ComponentAdapter</code>：组件适配器</p><p><code>ContainerAdapter：</code>容器适配器</p><p><code>FocusAdapter</code>：焦点适配器</p></li></ul></li></ul><h3 id="Swing"><a href="#Swing" class="headerlink" title="Swing"></a>Swing</h3><ul><li>Swing介绍：<ul><li>java1.2引入称为Swing的新的GUI组件库。它是一个用于开发java应用程序用户界面的开发工具包；</li><li>Swing控件是用纯java语言编写而成，不依赖与本地的操作系统的GUI，Swing控件可以跨平台运行。独立于本地平台的Swing控件被称为轻量级控件，而依赖于本地平台的AWT控件被称为重量级控件</li><li>它以抽象窗口工具包（AWT）为基础使跨平台应用程序可以使用任何可插拔的外观风格；</li><li>Swing开发人员只用很少的代码就可用Swing丰富、灵活的功能和模块化组件来创建优雅的用户界面；</li><li>工具包中所有的包都是以Swing作为名称，例如：javax.swing , javax.swing.event</li></ul></li><li>创建图形界面步骤：<ol><li>导入Swing包；</li><li>设置顶层容器；</li><li>设置按钮和标签等Swing组件；</li><li>将组建添加至倒容器中；</li><li>处理事件。</li></ol></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div></div></div><div><div class="my_post_copyright"><script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script><script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script><script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script><p><span>本文标题:</span><a href="/java基础（一）.html">java基础（一）</a></p><p><span>文章作者:</span><a href="/" title="访问 Mr.xiong 的个人博客">Mr.xiong</a></p><p><span>发布时间:</span>2019年12月03日 - 11:12</p><p><span>最后更新:</span>2019年12月03日 - 12:12</p><p><span>原始链接:</span><a href="/java基础（一）.html" title="java基础（一）">http://blog.xiongchang.vip/java基础（一）.html</a> <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="http://blog.xiongchang.vip/java基础（一）.html" aria-label="复制成功！"></i></span></p><p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">署名-非商业性使用-禁止演绎 4.0 国际</a> 转载请保留原文链接及作者。</p></div><script>var clipboard=new Clipboard(".fa-clipboard");$(".fa-clipboard").click(function(){clipboard.on("success",function(){swal({title:"",text:"复制成功",icon:"success",showConfirmButton:!0})})})</script></div><div class="reward-container"><div>请作者喝咖啡</div><button disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="http://imgs.xiongchang.vip/wx.png" alt="Mr.xiong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="http://imgs.xiongchang.vip/zfb.jpg" alt="Mr.xiong 支付宝"><p>支付宝</p></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/java/" rel="tag"><i class="fa fa-tag"></i> java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/Mybatis.html" rel="next" title="Mybatis"><i class="fa fa-chevron-left"></i> Mybatis</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/Linux常用命令（三）.html" rel="prev" title="Linux常用命令（三）">Linux常用命令（三） <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments" id="comments"></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基本概念"><span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#java-关键字"><span class="nav-text">java 关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-面向对象"><span class="nav-text">java 面向对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内部类"><span class="nav-text">内部类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部类的特点"><span class="nav-text">内部类的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#成员内部类"><span class="nav-text">成员内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态内部类"><span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名内部类"><span class="nav-text">匿名内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部内部类"><span class="nav-text">局部内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用函数"><span class="nav-text">常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类"><span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#String类"><span class="nav-text">String类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer类"><span class="nav-text">StringBuffer类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder类"><span class="nav-text">StringBuilder类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Date日期类、SimpleDateFormat类"><span class="nav-text">Date日期类、SimpleDateFormat类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Calendar类"><span class="nav-text">Calendar类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常"><span class="nav-text">异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-text">泛型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-text">集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集合框架-1"><span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#List-容器特点"><span class="nav-text">List 容器特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map接口"><span class="nav-text">Map接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set容器"><span class="nav-text">Set容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections类"><span class="nav-text">Collections类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GUI"><span class="nav-text">GUI</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#AWT框架"><span class="nav-text">AWT框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#布局管理器"><span class="nav-text">布局管理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AWT事件处理基本概念"><span class="nav-text">AWT事件处理基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Swing"><span class="nav-text">Swing</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><a href="/"><img class="site-author-image" itemprop="image" src="http://imgs.xiongchang.vip/head.jpeg" alt="Mr.xiong"></a><p class="site-author-name" itemprop="name">Mr.xiong</p><div class="site-description" itemprop="description">日行一善</div></div><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=467567680&auto=0&height=66"></iframe><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">17</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i>RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/xbrownbear" title="GitHub &rarr; https://github.com/xbrownbear" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:1070375764@qq.com" title="E-Mail &rarr; mailto:1070375764@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 推荐阅读</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="https://theme-next.org/docs/getting-started/" title="https://theme-next.org/docs/getting-started/" rel="noopener" target="_blank">Theme-nexT</a></li><li class="links-of-blogroll-item"><a href="https://www.google.com" title="https://www.google.com" rel="noopener" target="_blank">google</a></li><li class="links-of-blogroll-item"><a href="https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_66" title="https://blog.csdn.net/qq_36759224/article/details/85420403#font_colorFF0000___font_66" rel="noopener" target="_blank">TRHX</a></li></ul></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Mr.xiong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">135k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">2:03</span></div><div class="addthis_inline_share_toolbox"><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5da135c42387c827" async></script></div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span><script>function createtime(){var n=new Date("10/01/2019 13:14:21");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="本站已安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒"}var now=new Date;setInterval("createtime()",250)</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i> </span>访客量 <span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span> </span></span><span class="post-meta-divider">|</span> <span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span>访问量 <span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div></div></footer></div><script color="0,0,255" opacity="0.8" zindex="-1" count="300" src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script><script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.min.js"></script><script src="//cdn.jsdelivr.net/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js?v=7.4.1.js"></script><script src="/js/motion.js?v=7.4.1.js"></script><script src="/js/schemes/pisces.js?v=7.4.1.js"></script><script src="/js/next-boot.js?v=7.4.1.js"></script><script src="/js/local-search.js?v=7.4.1.js"></script><script>NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(item => {
    return GUEST.includes(item);
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: 'gXeDpwV5YvMCwOIWqpM23kRd-gzGzoHsz',
    appKey: 'P26X19DE4lLPJ3AqalUjTlVv',
    placeholder: '欢迎来踩......',
    avatar: 'hide',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn',
    path: location.pathname,
    recordIP: true,
    serverURLs: ''
  });
}, window.Valine);</script></body></html><script type="text/javascript" src="/js/src/love.js"></script><script type="text/javascript" src="/js/src/click_show_text.js"></script><canvas id="DigitalRain" width="1440" height="900"></canvas><script type="text/javascript" src="/js/src/DigitalRain.js"></script><script type="text/javascript" src="/js/src/FunnyTitle.js"></script><!-- rebuild by neat -->